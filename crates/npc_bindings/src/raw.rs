/* automatically generated by rust-bindgen 0.72.0 */

#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type std_integral_constant_value_type<_Ty> = _Ty;
pub type std_integral_constant_type = u8;
pub type std_bool_constant = u8;
pub type std_true_type = u8;
pub type std_enable_if_t = u8;
pub type std_conditional_type<_Ty1> = _Ty1;
pub type std_conditional_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Iterator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std__Iter_ref_t = std_iterator_traits;
pub type std__Iter_value_t = std_iterator_traits;
pub type std__Iter_diff_t = std_iterator_traits;
pub type std__Iter_cat_t = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_BidIt> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_BidIt>>,
    pub current: _BidIt,
}
pub type std_reverse_iterator_iterator_type<_BidIt> = _BidIt;
pub type std_reverse_iterator_iterator_category = std__Iter_cat_t;
pub type std_reverse_iterator_value_type = std__Iter_value_t;
pub type std_reverse_iterator_difference_type = std__Iter_diff_t;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_reference = std__Iter_ref_t;
pub type std_reverse_iterator__Prevent_inheriting_unwrap<_BidIt> = std_reverse_iterator<_BidIt>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std__Rebind_alloc_t = std_allocator_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator__From_primary = std_allocator;
pub type std_allocator_value_type<_Ty> = _Ty;
pub type std_allocator_pointer<_Ty> = *mut _Ty;
pub type std_allocator_const_pointer<_Ty> = *const _Ty;
pub type std_allocator_reference<_Ty> = *mut _Ty;
pub type std_allocator_const_reference<_Ty> = *const _Ty;
pub type std_allocator_size_type = ::std::os::raw::c_ulonglong;
pub type std_allocator_difference_type = ::std::os::raw::c_longlong;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Container_base0 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Iterator_base0 {
    pub _address: u8,
}
pub const std__Iterator_base0__Unwrap_when_unverified: bool = true;
pub type std__Container_base = std__Container_base0;
pub type std__Iterator_base = std__Iterator_base0;
pub type std__Compressed_pair__Mybase<_Ty1> = _Ty1;
#[repr(C)]
pub struct std__Vector_const_iterator {
    pub _Ptr: std__Vector_const_iterator__Tptr,
}
pub type std__Vector_const_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__Vector_const_iterator_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_const_iterator_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_const_iterator_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_const_iterator_reference = *const std__Vector_const_iterator_value_type;
pub type std__Vector_const_iterator__Tptr = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_const_iterator__Prevent_inheriting_unwrap = std__Vector_const_iterator;
#[repr(C)]
pub struct std__Vector_iterator {
    pub _base: std__Vector_const_iterator,
}
pub type std__Vector_iterator__Mybase = std__Vector_const_iterator;
pub type std__Vector_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__Vector_iterator_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_iterator_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_iterator_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_iterator_reference = *mut std__Vector_iterator_value_type;
pub type std__Vector_iterator__Prevent_inheriting_unwrap = std__Vector_iterator;
#[repr(C)]
pub struct std__Vector_val {
    pub _Myfirst: std__Vector_val_pointer,
    pub _Mylast: std__Vector_val_pointer,
    pub _Myend: std__Vector_val_pointer,
}
pub type std__Vector_val_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_val_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_val_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_val_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_val_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_val_reference = *mut std__Vector_val_value_type;
pub type std__Vector_val_const_reference = *const std__Vector_val_value_type;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector {
    pub _Mypair: u8,
}
pub type std_vector__Alty = std__Rebind_alloc_t;
pub type std_vector__Alty_traits = std_allocator_traits;
pub type std_vector_value_type<_Ty> = _Ty;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
pub type std_vector_pointer = std_vector__Alty_traits;
pub type std_vector_const_pointer = std_vector__Alty_traits;
pub type std_vector_reference<_Ty> = *mut _Ty;
pub type std_vector_const_reference<_Ty> = *const _Ty;
pub type std_vector_size_type = std_vector__Alty_traits;
pub type std_vector_difference_type = std_vector__Alty_traits;
pub type std_vector__Scary_val = std__Vector_val;
pub type std_vector_iterator = std__Vector_iterator;
pub type std_vector_const_iterator = std__Vector_const_iterator;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub const std_vector__Reallocation_policy__At_least: std_vector__Reallocation_policy = 0;
pub const std_vector__Reallocation_policy__Exactly: std_vector__Reallocation_policy = 0;
pub type std_vector__Reallocation_policy = ::std::os::raw::c_int;
pub type std_streamoff = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_Statetype> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Statetype>>,
    pub _Myoff: std_streamoff,
    pub _Fpos: ::std::os::raw::c_longlong,
    pub _Mystate: _Statetype,
}
pub type std_streampos = std_fpos<_Mbstatet>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Char_traits {
    pub _address: u8,
}
pub type std__Char_traits_char_type<_Elem> = _Elem;
pub type std__Char_traits_int_type<_Int_type> = _Int_type;
pub type std__Char_traits_pos_type = std_streampos;
pub type std__Char_traits_off_type = std_streamoff;
pub type std__Char_traits_state_type = _Mbstatet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
pub struct std__String_const_iterator {
    pub _Ptr: std__String_const_iterator_pointer,
}
pub type std__String_const_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__String_const_iterator_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_const_iterator_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_const_iterator_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_const_iterator_reference = *const std__String_const_iterator_value_type;
pub type std__String_const_iterator__Prevent_inheriting_unwrap = std__String_const_iterator;
#[repr(C)]
pub struct std__String_iterator {
    pub _base: std__String_const_iterator,
}
pub type std__String_iterator__Mybase = std__String_const_iterator;
pub type std__String_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__String_iterator_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_iterator_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_iterator_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_iterator_reference = *mut std__String_iterator_value_type;
pub type std__String_iterator__Prevent_inheriting_unwrap = std__String_iterator;
#[repr(C)]
pub struct std__String_val {
    pub _Bx: std__String_val__Bxty,
    pub _Mysize: std__String_val_size_type,
    pub _Myres: std__String_val_size_type,
}
pub type std__String_val_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_val_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_val_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_val_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_val_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std__String_val_reference = *mut std__String_val_value_type;
pub type std__String_val_const_reference = *const std__String_val_value_type;
#[repr(C)]
pub struct std__String_val__Bxty {
    pub _Buf: __BindgenUnionField<*mut std__String_val_value_type>,
    pub _Ptr: __BindgenUnionField<std__String_val_pointer>,
    pub _Alias: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_string {
    pub _Mypair: u8,
}
pub type std_basic_string__Alty = std__Rebind_alloc_t;
pub type std_basic_string__Alty_traits = std_allocator_traits;
pub type std_basic_string__Scary_val = std__String_val;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_allocator_type<_Alloc> = _Alloc;
pub type std_basic_string_value_type<_Elem> = _Elem;
pub type std_basic_string_size_type = std_basic_string__Alty_traits;
pub type std_basic_string_difference_type = std_basic_string__Alty_traits;
pub type std_basic_string_pointer = std_basic_string__Alty_traits;
pub type std_basic_string_const_pointer = std_basic_string__Alty_traits;
pub type std_basic_string_reference<_Elem> = *mut std_basic_string_value_type<_Elem>;
pub type std_basic_string_const_reference<_Elem> = *const std_basic_string_value_type<_Elem>;
pub type std_basic_string_iterator = std__String_iterator;
pub type std_basic_string_const_iterator = std__String_const_iterator;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string__Is_elem_cptr = std_bool_constant;
pub type std_basic_string__Is_string_view_ish = std_enable_if_t;
pub const std_basic_string__Allocation_policy__At_least: std_basic_string__Allocation_policy = 0;
pub const std_basic_string__Allocation_policy__Exactly: std_basic_string__Allocation_policy = 0;
pub type std_basic_string__Allocation_policy = ::std::os::raw::c_int;
pub const std_basic_string__Construct_strategy__From_char: std_basic_string__Construct_strategy = 0;
pub const std_basic_string__Construct_strategy__From_ptr: std_basic_string__Construct_strategy = 0;
pub const std_basic_string__Construct_strategy__From_string: std_basic_string__Construct_strategy =
    0;
pub type std_basic_string__Construct_strategy = ::std::os::raw::c_uchar;
pub type std_string = std_basic_string;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
pub type fn_StartRecordingPlayerData = ::std::option::Option<
    unsafe extern "C" fn(playerId: i32, recordtype: u8, recordname: std_string, flags: u32) -> bool,
>;
pub type fn_StopRecordingPlayerData =
    ::std::option::Option<unsafe extern "C" fn(playerId: i32) -> bool>;
pub type fn_CallNPCClient = ::std::option::Option<
    unsafe extern "C" fn(
        szName: *const ::std::os::raw::c_char,
        szScript: *const ::std::os::raw::c_char,
        bConsoleInputEnabled: bool,
        host: *const ::std::os::raw::c_char,
        plugins: *const ::std::os::raw::c_char,
        execArg: *const ::std::os::raw::c_char,
        loc: *const ::std::os::raw::c_char,
        params: std_vector,
    ) -> bool,
>;
pub type fn_IsPlayerNPC = ::std::option::Option<unsafe extern "C" fn(playerId: u8) -> bool>;
pub type fn_StartRecordingAllPlayerData = ::std::option::Option<
    unsafe extern "C" fn(recordtype: u8, flags: u32, recordnewplayers: bool) -> u8,
>;
pub type fn_StopRecordingAllPlayerData = ::std::option::Option<unsafe extern "C" fn() -> u8>;
pub type fn_IsPlayerRecording =
    ::std::option::Option<unsafe extern "C" fn(bytePlayerId: u8) -> bool>;
pub type fn_PutServerInRecordingMode = ::std::option::Option<
    unsafe extern "C" fn(recordtype: u8, flags: u32, filename: std_string) -> bool,
>;
pub type fn_StopServerInRecordingMode = ::std::option::Option<unsafe extern "C" fn() -> bool>;
pub type fn_IsServerInRecordingMode = ::std::option::Option<unsafe extern "C" fn() -> bool>;
pub type fn_StopConnectingMultipleNpcs = ::std::option::Option<unsafe extern "C" fn() -> bool>;
pub type fn_ConnectMultipleNpcs = ::std::option::Option<
    unsafe extern "C" fn(
        filename: std_string,
        host: std_string,
        flags: u32,
        execArg: std_string,
    ) -> u8,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NPCExports {
    pub uStructSize: ::std::os::raw::c_uint,
    pub StartRecordingPlayerData: fn_StartRecordingPlayerData,
    pub StopRecordingPlayerData: fn_StopRecordingPlayerData,
    pub CallNPCClient: fn_CallNPCClient,
    pub IsPlayerNPC: fn_IsPlayerNPC,
    pub StartRecordingAllPlayerData: fn_StartRecordingAllPlayerData,
    pub StopRecordingAllPlayerData: fn_StopRecordingAllPlayerData,
    pub IsPlayerRecording: fn_IsPlayerRecording,
    pub PutServerInRecordingMode: fn_PutServerInRecordingMode,
    pub StopServerInRecordingMode: fn_StopServerInRecordingMode,
    pub IsServerInRecordingMode: fn_IsServerInRecordingMode,
    pub StopConnectingMultipleNpcs: fn_StopConnectingMultipleNpcs,
    pub ConnectMultipleNpcs: fn_ConnectMultipleNpcs,
}
